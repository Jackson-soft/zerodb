zeroProxy是golang开发的一个长连接Server

![](http://processon.com/chart_image/5a6039fce4b0332f15386a52.png?_=10)

### Concurrent
由于golang的并发单位是协程而不是线程，所以不可避免得会提及一点golang调度器。协程是一种比线程更加轻量的并发单位，它的上下文切换不是直接由OS内核调度，而是go scheduler。但是go进程也是运行在OS上，所以是go调度器会开发者屏蔽了复杂的线程创建工作。为什么说线程创建很复杂？给你一个程序，只要你看一遍说不出开大概多少线程并发最好，那就是复杂的，而go调度器会根据自身的运行情况多态调整线程的数量，简直是程序的性能管家。正常4C8G的Linux下，几万的并发也是轻松驾驭的。
![](http://processon.com/chart_image/5b69b83ae4b0555b39d85890.png?_=1001)

### NIO
在Java世界中，NIO编程是一项非常难以精通的点，首先要理解NIO中select->poll->epoll/kqueue是怎么样工作的，还有每一个net poller的在性能上的提高。但在Golang中，net.tcp包中的所有底层网络读写全部都是非阻塞的，只是给了一个好用的阻塞IO的API。不可否认，阻塞式的API才是比较符合一般程序编写习惯的。「非阻塞底层IO」包装成「协程级别阻塞的IO」的主要功臣是go调度器。

### DBPool
Proxy->MySQL的连接采用连接池管理。连接池内部的每一个MySQLConn在初始化的时候已经全部创建了，所以涉及到连接的borrow和return不会涉及到内存的分配和回收，效率会有不小的提高。并且给每个连接池设计了水位控制，低于水位线进行连接补充，高于水位线进行连接驱逐，等于水位线进行连接保活。

### 内存缓存
Proxy作为一个长连接服务器，服务端每次Accept了一个新的连接后，将会为这个连接的整个生命周期服务，中间就不得不涉及到分配ByteBuffer以用作SQL解析或者网络传输。如果高效得分配内存成为Proxy的性能的一大关键，由于每一个长连接都是由一个协程来管理，并且，大部分的SQL都是路由到一个节点，那么Goroutine-MemoryAllocator就成了内存分配机制的首选。服务端在每次Accept一个新的连接后，在协程中创建一个内存分配器，
每一次内存的分配和回收都不需要依赖于并发锁。如果SQL路由成到了多个节点，那多个节点需要多协程并发，这时才依赖并发安全的内存分配机制，而整个Proxy几乎有95%以上的SQL都是单节点路由。
